# GeoGebra Integration in Next.js 15 with React 19: Research Report

## 1. Issue Summary

The primary issue is that GeoGebra widgets are not rendering in the ChatInterface, despite being generated by the intelligent tutoring system. The secondary issue is that markers like `[SHAPE:cube,4]` are not properly triggering the display of dynamic GeoGebra applets. These problems stem from compatibility challenges between GeoGebra's client-side rendering model and Next.js 15's App Router, which utilizes React 19 features such as Server Components, concurrent rendering, and strict SSR (Server-Side Rendering) hydration rules.

The integration fails due to:
- SSR environment limitations (no `window`, `document`)
- Improper timing of script loading and DOM injection
- Lack of cleanup, causing "app was already removed" errors
- Multiple applets overwriting global `window.ggbApplet`
- Dynamic content not waiting for `window.GGBApplet` initialization

This report provides a comprehensive solution based on authoritative documentation and working patterns.

## 2. GeoGebra Widget Rendering in ChatInterface: Root Causes and Solutions

### 2.1. SSR and Client-Side Compatibility Issues

GeoGebra relies on the `window.GGBApplet` object, which is only available in the browser. In Next.js 15 using the App Router, components are rendered server-side by default. Accessing `window` during server rendering causes a `ReferenceError`, breaking component initialization.

**Key Finding**: The `useEffect` hook is safe because it only runs on the client side after hydration.

**Solution**: Always check for `window` existence or wrap GeoGebra-related logic inside `useEffect`, which guarantees client-side execution:

```javascript
useEffect(() => {
  if (typeof window !== 'undefined') {
    // Proceed with GGBApplet
  }
}, []);
```

Additionally, import the component using the `'use client'` directive to designate it as a Client Component, ensuring React 19 handles it correctly in the App Router.

### 2.2. Script Loading and Timing with deployggb.js

The `deployggb.js` script from GeoGebra's CDN is required to initialize `window.GGBApplet`. However, in Next.js, this script must not block server rendering, and its loading must be synchronized with component mounting.

**Key Finding**: Direct `<script>` tags in components are not re-executed on client transitions in Next.js due to React's hydration model.

**Solution**: Use Next.js's built-in `next/script` component to load external scripts safely in the App Router:

```javascript
import Script from 'next/script'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        {children}
        <Script
          src="https://www.geogebra.org/apps/deployggb.js"
          strategy="afterInteractive"
        />
      </body>
    </html>
  )
}
```

The `afterInteractive` strategy ensures the script loads after the page becomes interactive, avoiding SSR blocking while loading soon enough for user interaction.

### 2.3. When is window.GGBApplet Available?

`window.GGBApplet` is only available after `deployggb.js` has fully loaded and initialized. Accessing it too early (e.g., in component mount without waiting) results in `undefined`.

**Key Finding**: The GeoGebra API recommends using the `appletOnLoad` callback to execute code once the applet is ready.

Thus, do not rely on `useEffect` alone to create the applet. Instead, ensure `deployggb.js` is loaded, and use `appletOnLoad` to confirm readiness.

## 3. Dynamic Content Integration and Widget Injection

### 3.1. Injecting GeoGebra Applets Dynamically

Dynamic content (such as chat messages) generates GeoGebra markers like `[SHAPE:cube,4]`. To render them, the system must:
1. Parse the marker
2. Create a DOM container
3. Initialize and inject a GGBApplet into that container

**Key Finding**: The `inject()` method must be called after the DOM element exists and GGBApplet is loaded.

**Pattern**: Use ref and useEffect to ensure the container is mounted:

```javascript
const containerRef = useRef(null);
useEffect(() => {
  const container = containerRef.current;
  if (!container) return;
  const applet = new window.GGBApplet(config, true);
  applet.inject(container);
}, []);
```

### 3.2. React Component Integration with useState and Lifecycle

While older tutorials reference `componentDidMount` (a class component lifecycle method), modern React (including React 19) uses functional components with `useState` and `useEffect`.

**Best Practice**: Use `useEffect` for initialization and cleanup, `useState` for controlling visibility or parameters of the applet.

**Example**:
```javascript
const [isLoaded, setIsLoaded] = useState(false);
useEffect(() => {
  const config = {
    appletOnLoad: () => setIsLoaded(true),
  };
  const applet = new window.GGBApplet(config, false);
  applet.inject(containerRef.current);
  return () => applet.remove(); // cleanup
}, []);
```

## 4. Error Handling and Debugging

### 4.1. "App was already removed" and Multiple Applets

This error commonly occurs when:
- Multiple applets try to use the same global variable (`ggbApplet`)
- An applet is removed but still referenced
- Cleanup is not performed on unmount

**Key Finding**: The `ggbApplet` global variable always refers to the last active applet. For multiple applets, a unique `id` must be assigned.

**Solution**: Always assign a unique `id` in the configuration:

```javascript
const config = {
  id: "ggbApplet1",
  appletOnLoad: (api) => {
    window.ggbApplet1 = api; // store in window
  }
};
```

Then, before creating a new applet, check and clean up:

```javascript
if (window.ggbApplet1?.remove) {
  window.ggbApplet1.remove();
  delete window.ggbApplet1;
}
```

The `remove()` method frees memory and prevents conflicts.

### 4.2. Debugging Initialization Failures

To debug:
- Use `debug: true` in GeoGebra parameters
- Monitor browser console for errors
- Add logging in `appletOnLoad`
- Ensure CDN script loads (check Network tab)

GeoGebra provides a `debug(String)` method for logging, but using `console.log` in `appletOnLoad` is more practical during development.

## 5. Best Practices for GeoGebra and React Integration

### 5.1. Lifecycle-Aware Component Design

| Stage | Action |
|-------|--------|
| Mount | Wait for `deployggb.js`, then initialize with unique `id` |
| Update | Re-inject only if parameters change (controlled via `useEffect` deps) |
| Unmount | Call `applet.remove()` and clean up window references |

This pattern prevents memory leaks and "already removed" errors.

### 5.2. Dynamic and Multiple Applet Management

For rendering multiple dynamic GeoGebra widgets (e.g., per chat message), create a reusable component:

```javascript
'use client'
import { useEffect, useRef } from 'react';

export default function GeoGebraWidget({ id, parameters, onReady }) {
  const containerRef = useRef(null);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    if (!containerRef.current) return;

    // Ensure unique window reference
    const config = {
      ...parameters,
      id,
      appletOnLoad: (api) => {
        window[id] = api;
        onReady?.(api);
      },
    };

    // Cleanup previous instance
    if (window[id]?.remove) {
      window[id].remove();
      delete window[id];
    }

    const applet = new window.GGBApplet(config, false);
    applet.inject(containerRef.current);

    return () => {
      if (window[id]?.remove) {
        window[id].remove();
        delete window[id];
      }
    };
  }, [id, parameters, onReady]);

  return <div ref={containerRef} style={{ width: '100%', height: '400px' }} />;
}
```

This pattern:
- Prevents global variable conflicts
- Ensures cleanup
- Uses `useEffect` for lifecycle control
- Supports dynamic creation in chat messages

### 5.3. Parsing and Rendering [SHAPE:...] Markers

The intelligent tutoring system should:
1. Parse messages for markers like `[SHAPE:cube,4]`
2. Extract shape and parameters
3. Render `<GeoGebraWidget />` with unique id (e.g., `ggb-${messageId}`)

**Example**:
```javascript
function renderMessage(content) {
  const shapeMatch = content.match(/\[SHAPE:(\w+),(\d+)\]/);
  if (shapeMatch) {
    const [, shape, size] = shapeMatch;
    const widgetId = `ggb-${messageId}`;
    return (
      <div>
        {/* Render other content */}
        <GeoGebraWidget
          id={widgetId}
          parameters={{ material_id: getMaterialId(shape) }}
        />
      </div>
    );
  }
}
```

## 6. Available Tools and Libraries

### 6.1. react-geogebra npm Package

An unofficial but actively used wrapper is available at `npmjs.com/package/react-geogebra`.

**Features**:
- Wraps `deployggb.js` loading
- Accepts `id` for multiple instances
- Provides `onReady` and `LoadComponent` props
- Handles cleanup internally

```jsx
<Geogebra id="app1" appName="3d" width="800" height="600" />
```

While not official, it follows the same patterns recommended here and can be used as a starting point.

### 6.2. Official GeoGebra Documentation

- **GeoGebra Apps API** — Comprehensive API reference with `appletOnLoad`, `inject`, and `remove()`
- **Embedding Guide** — Details on script loading and configuration

The documentation confirms:
- Use `appletOnLoad` to get API access
- Use `id` for multiple applets
- Call `remove()` to dispose

## 7. Conclusion and Action Items

To resolve all reported issues, implement the following:

### ✅ Step-by-Step Fixes

1. **Load deployggb.js with next/script**
   - Strategy: `afterInteractive`
   - Place in RootLayout

2. **Create a GeoGebraWidget Client Component**
   - Use `useEffect` and `useRef`
   - Assign unique `id`
   - Inject into DOM container
   - Cleanup with `remove()` on unmount

3. **Parse and Render Markers Dynamically**
   - Detect `[SHAPE:...]` in chat messages
   - Instantiate `GeoGebraWidget` with unique IDs

4. **Handle Errors Proactively**
   - Always check if `window[id]?.remove` exists
   - Never re-inject without cleanup
   - Use `appletOnLoad` for post-initialization logic

### Best Practices Enforced
- `'use client'` directive
- Unique `id` for every applet
- Cleanup on unmount
- Client-only access to `window`

## 8. Expected Outcome

With these changes:
- GeoGebra widgets will render in ChatInterface
- `[SHAPE:...]` markers will generate working dynamic applets
- "app was already removed" errors will be eliminated
- Memory and conflicts from multiple applets will be mitigated
- Integration will be robust, scalable, and SSR-safe

The solution leverages authoritative sources including the Next.js Script documentation and GeoGebra's official API reference, ensuring long-term compatibility with Next.js 15 and React 19.

## 9. Implementation Status in Our Codebase

### Current Components
- `GeoGebraWidget.tsx` - Core widget component with iframe isolation
- `ChatGeoGebra.tsx` - Chat interface integration
- `SmartGeoGebraFrame.tsx` - Intelligent applet manager

### Required Changes Based on Research
1. **Add deployggb.js to RootLayout** - Not yet implemented
2. **Implement unique ID system** - Partially implemented
3. **Add proper cleanup in useEffect** - Needs enhancement
4. **Parse [SHAPE:...] markers in ChatInterface** - Not yet implemented
5. **Add appletOnLoad callbacks** - Needs implementation

### Next Steps
1. Update `layout.tsx` to include deployggb.js script
2. Enhance `ChatGeoGebra.tsx` with proper lifecycle management
3. Implement marker parsing in `ChatInterface.tsx`
4. Add comprehensive error handling and debugging
